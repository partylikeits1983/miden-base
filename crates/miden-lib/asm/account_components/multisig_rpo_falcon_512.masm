# The MASM code of the Multi-Signature RPO Falcon 512 Authentication Component.

use.miden::account
use.miden::auth
use.miden::tx

# CONSTANTS
# =================================================================================================

# Auth Request Constants

# The event emitted when a signature is not found for a required signer.
const.UNAUTHORIZED_EVENT=131102

# Storage Layout Constants
#
# ┌─────────────────────────────┬──────────┬──────────────┐
# │    THRESHOLD & APPROVERS    │ PUB KEYS │ EXECUTED TXS │
# │           (slot)            │   (map)  │    (map)     │
# ├─────────────────────────────┼──────────┼──────────────┤
# │              0              │    1     │      2       │
# └─────────────────────────────┴──────────┴──────────────┘

# The slot in this component's storage layout where both the signature threshold
# and number of approvers are stored as [threshold, num_approvers, 0, 0].
# The threshold is guaranteed to be less than or equal to num_approvers.
const.THRESHOLD_CONFIG_SLOT=0

# The slot in this component's storage layout where the public keys map is stored.
# Map entries: [key_index, 0, 0, 0] => owner_public_key
const.PUBLIC_KEYS_MAP_SLOT=1

# The slot in this component's storage layout where executed transactions are stored.
# Map entries: transaction_message => [is_executed, 0, 0, 0]
const.EXECUTED_TXS_SLOT=2

# Executed Transaction Flag Constant
const.IS_EXECUTED_FLAG=[1, 0, 0, 0]

# ERRORS
const.ERR_TX_ALREADY_EXECUTED="failed to approve multisig transaction as it was already executed"

#! Check if transaction has already been executed and add it to executed transactions for replay protection.
#!
#! Inputs:  [MSG]
#! Outputs: []
#!
#! Panics if:
#! - the same transaction has already been executed
proc.assert_new_tx
    push.IS_EXECUTED_FLAG
    # => [[0, 0, 0, is_executed], MSG]

    swapw
    # => [MSG, IS_EXECUTED_FLAG]

    push.EXECUTED_TXS_SLOT
    # => [index, MSG, IS_EXECUTED_FLAG]

    # Set the key value pair in the map to mark transaction as executed
    exec.account::set_map_item
    # => [OLD_MAP_ROOT, [0, 0, 0, is_executed]]

    dropw drop drop drop
    # => [is_executed]

    assertz.err=ERR_TX_ALREADY_EXECUTED
    # => []
end

#! Authenticate a transaction using the Falcon signature scheme with multi-signature support.
#!
#! This procedure implements multi-signature authentication by:
#! 1. Computing the transaction summary message that needs to be signed
#! 2. Verifying signatures from multiple required signers against their public keys
#! 3. Ensuring the minimum threshold of valid signatures is met
#! 4. Implementing replay protection by tracking executed transactions
#!
#! Inputs:
#!   Operand stack: [SALT]
#!   Advice map: {
#!     h(SIG_0, MSG): SIG_0,
#!     h(SIG_1, MSG): SIG_1,
#!     h(SIG_n, MSG): SIG_n
#!   }
#! Outputs:
#!   Operand stack: []
#!
#! Where:
#! - SALT is a cryptographically random nonce that enables multiple concurrent
#!   multisig transactions while maintaining replay protection. Each transaction
#!   must use a unique SALT value to ensure transaction uniqueness.
#! - SIG_i is the signature from the i-th signer.
#! - MSG is the transaction message being signed.
#! - h(SIG_i, MSG) is the hash of the signature and message used as the advice map key.
#!
#! Panics if:
#! - insufficient number of valid signatures (below threshold).
#! - the same transaction has already been executed (replay protection).
#!
#! Invocation: call
export.auth__tx_rpo_falcon512_multisig
    exec.account::incr_nonce drop
    # => [SALT]

    # ------ Computing transaction summary ------

    exec.auth::create_tx_summary
    # => [SALT, OUTPUT_NOTES_COMMITMENT, INPUT_NOTES_COMMITMENT, ACCOUNT_DELTA_COMMITMENT]

    # to build a tx_summary in the host, we need these four words in the advice provider
    exec.auth::adv_insert_hqword
    # => [SALT, OUTPUT_NOTES_COMMITMENT, INPUT_NOTES_COMMITMENT, ACCOUNT_DELTA_COMMITMENT]

    # the commitment to the tx summary is the message that is signed
    exec.auth::hash_tx_summary
    # => [TX_SUMMARY_COMMITMENT]

    # ------ Verifying owner signatures ------

    push.THRESHOLD_CONFIG_SLOT
    # => [index, TX_SUMMARY_COMMITMENT]

    exec.account::get_item
    # => [0, 0, num_of_approvers, threshold, TX_SUMMARY_COMMITMENT]

    drop drop
    # => [num_of_approvers, threshold, TX_SUMMARY_COMMITMENT]

    swap movdn.5
    # => [num_of_approvers, TX_SUMMARY_COMMITMENT, threshold]

    push.PUBLIC_KEYS_MAP_SLOT
    # => [pub_key_slot_idx, num_of_approvers, TX_SUMMARY_COMMITMENT, threshold]

    exec.::miden::auth::rpo_falcon512::verify_signatures
    # => [num_verified_signatures, TX_SUMMARY_COMMITMENT, threshold]

    # ------ Checking threshold is >= num_verified_signatures ------

    movup.5
    # => [threshold, num_verified_signatures, TX_SUMMARY_COMMITMENT]

    u32assert2 u32lt
    # => [is_unauthorized, TX_SUMMARY_COMMITMENT]

    # If signatures are non-existent the tx will fail here.
    if.true
        emit.UNAUTHORIZED_EVENT
        push.0 assert.err="insufficient number of signatures"
    end

    # ------ Writing executed transaction MSG to map ------

    exec.assert_new_tx
    # => [TX_SUMMARY_COMMITMENT]
end
